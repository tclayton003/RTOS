<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>A3200CommandandManagementSDK: lib/libembed/include/gs/embed/stm32/stm32l4/drivers/watchdog/watchdog.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A3200CommandandManagementSDK
   &#160;<span id="projectnumber">2.12.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_e920b9c1201c0f83c04b197e3d83dc03.html">libembed</a></li><li class="navelem"><a class="el" href="dir_66497346ec6d4a900394cb78f6b50c7b.html">include</a></li><li class="navelem"><a class="el" href="dir_b840ce86c205ade48ed9c9ff7056450a.html">gs</a></li><li class="navelem"><a class="el" href="dir_598e7fb570cbef5189c38ce97c70adaf.html">embed</a></li><li class="navelem"><a class="el" href="dir_c1d15865617ef6289c4aba89350d1d42.html">stm32</a></li><li class="navelem"><a class="el" href="dir_df03909439b99763f7adac73227acf4e.html">stm32l4</a></li><li class="navelem"><a class="el" href="dir_11a54de24d1886fdc868b808d4561e40.html">drivers</a></li><li class="navelem"><a class="el" href="dir_1e80fa824afeff5b3157319ff7ffabca.html">watchdog</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">watchdog.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>STM32L4 watchdog API. </p>
<p>This API includes initialization of two different watchdogs. The independent watchdog is what GS use as the standard. It is capable of of longer timeouts. The window watchdog is more precise, and can also be used to just generate a interrupt. </p>
</div><div class="textblock"><code>#include &lt;<a class="el" href="device_8h_source.html">gs/util/drivers/watchdog/device.h</a>&gt;</code><br />
</div>
<p><a href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3df8caa8bedc25f6fa38be954b48d452"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3df8caa8bedc25f6fa38be954b48d452"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#a3df8caa8bedc25f6fa38be954b48d452">gs_watchdog_wwdg_callback_t</a>) (void)</td></tr>
<tr class="memdesc:a3df8caa8bedc25f6fa38be954b48d452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback from ISR, which the window watchdog can be configured to call instead of a reset generation. <br /></td></tr>
<tr class="separator:a3df8caa8bedc25f6fa38be954b48d452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aac2709bcf8573457d3cfed3c46284bc4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="device_8h.html#ad3355f08d7a5ab10f7b5ed520bd2ae1c">gs_watchdog_dev_ops_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#aac2709bcf8573457d3cfed3c46284bc4">gs_stm32l4_watchdog_get_dev_ops</a> (void)</td></tr>
<tr class="memdesc:aac2709bcf8573457d3cfed3c46284bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device operations for libutil watchdog API.  <a href="#aac2709bcf8573457d3cfed3c46284bc4">More...</a><br /></td></tr>
<tr class="separator:aac2709bcf8573457d3cfed3c46284bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d836c1b937a5530fd8f94906ac9623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#a14d836c1b937a5530fd8f94906ac9623">gs_stm32l4_watchdog_iwdg_init</a> (uint32_t timeout_val_ms)</td></tr>
<tr class="memdesc:a14d836c1b937a5530fd8f94906ac9623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize independent watchdog with specific timeout (this is the standard watchdog)  <a href="#a14d836c1b937a5530fd8f94906ac9623">More...</a><br /></td></tr>
<tr class="separator:a14d836c1b937a5530fd8f94906ac9623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa838b564f5ac4657f2f93b5057a7129b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#aa838b564f5ac4657f2f93b5057a7129b">gs_stm32l4_watchdog_iwdg_kick</a> (void)</td></tr>
<tr class="memdesc:aa838b564f5ac4657f2f93b5057a7129b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kicking/resetting the independent watchdog, which prevents reset.  <a href="#aa838b564f5ac4657f2f93b5057a7129b">More...</a><br /></td></tr>
<tr class="separator:aa838b564f5ac4657f2f93b5057a7129b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ab686b4f3a716c32f6fdff6fb26392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#a01ab686b4f3a716c32f6fdff6fb26392">gs_stm32l4_watchdog_wwdg_init</a> (float timeout_ms, <a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#a3df8caa8bedc25f6fa38be954b48d452">gs_watchdog_wwdg_callback_t</a> callback, float *timeout_ms_achieved)</td></tr>
<tr class="memdesc:a01ab686b4f3a716c32f6fdff6fb26392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize system window watchdog with specific timeout.  <a href="#a01ab686b4f3a716c32f6fdff6fb26392">More...</a><br /></td></tr>
<tr class="separator:a01ab686b4f3a716c32f6fdff6fb26392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00df1590c675e261eadecbd64ca438ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#a00df1590c675e261eadecbd64ca438ab">gs_stm32l4_watchdog_wwdg_kick</a> (void)</td></tr>
<tr class="memdesc:a00df1590c675e261eadecbd64ca438ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kicking/resetting the system window watchdog, which prevents reset.  <a href="#a00df1590c675e261eadecbd64ca438ab">More...</a><br /></td></tr>
<tr class="separator:a00df1590c675e261eadecbd64ca438ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aac2709bcf8573457d3cfed3c46284bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="device_8h.html#ad3355f08d7a5ab10f7b5ed520bd2ae1c">gs_watchdog_dev_ops_t</a>* gs_stm32l4_watchdog_get_dev_ops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device operations for libutil watchdog API. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to device operations </dd></dl>

</div>
</div>
<a class="anchor" id="a14d836c1b937a5530fd8f94906ac9623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_stm32l4_watchdog_iwdg_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_val_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize independent watchdog with specific timeout (this is the standard watchdog) </p>
<dl class="section note"><dt>Note</dt><dd>Can be configured to call a callback instead of generating reset. But if watchdog ISR for some reason is not called, a reset is generated anyway. </dd>
<dd>
The range of of achievable timeouts is dependent on the specific clock setup. The watchdog clock is derived from PCLK1. The PLCK1 is derived from the SYSCLK through two dividers. Example: If SYSCLK is 80 MHz and no dividers is used to PLCK1, then the span of achievable timeout is within the span [51.2 µs: 26.2 ms]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_val_ms</td><td>Desired timeout in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aa838b564f5ac4657f2f93b5057a7129b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_stm32l4_watchdog_iwdg_kick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kicking/resetting the independent watchdog, which prevents reset. </p>
<dl class="section return"><dt>Returns</dt><dd>GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a01ab686b4f3a716c32f6fdff6fb26392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_stm32l4_watchdog_wwdg_init </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libembed_2include_2gs_2embed_2stm32_2stm32l4_2drivers_2watchdog_2watchdog_8h.html#a3df8caa8bedc25f6fa38be954b48d452">gs_watchdog_wwdg_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>timeout_ms_achieved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize system window watchdog with specific timeout. </p>
<dl class="section note"><dt>Note</dt><dd>Can be configured to call a callback instead of generating reset. But if watchdog ISR for some reason is not called, a reset is generated anyway. </dd>
<dd>
The range of of achievable timeouts is dependent on the specific clock setup. The watchdog clock is derived from PCLK1. The PLCK1 is derived from the SYSCLK through two dividers. Example: If SYSCLK is 80 MHz and no dividers is used to PLCK1, then the span of achievable timeout is within the span [51.2 µs: 26.2 ms]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Desired timeout in milliseconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Watchdog callback (can be NULL), if set this callback is called instead of generating a reset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeout_ms_achieved</td><td>The actual achieved timeout in milliseconds (can be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a00df1590c675e261eadecbd64ca438ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libutil_2include_2gs_2util_2error_8h.html#a91aea7d2bf231aa2a13f95a6c5305cbc">gs_error_t</a> gs_stm32l4_watchdog_wwdg_kick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kicking/resetting the system window watchdog, which prevents reset. </p>
<dl class="section return"><dt>Returns</dt><dd>GS_OK on success </dd>
<dd>
other error code on failure </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
    <table width="100%" border="0">
      <tr>
	<td>Copyright &copy; 2013-2020 GomSpace A/S. All rights reserved. </td>
	<td><right>Generated by Doxygen 1.8.11</right></td>
      </tr>
    </table>
</small></address>
</body>
</html>
